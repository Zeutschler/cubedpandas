{
  "config": {
    "lang": [
      "en"
    ],
    "separator": "[\\s\\-]+",
    "pipeline": [
      "stopWordFilter"
    ]
  },
  "docs": [
    {
      "location": "",
      "title": "CubedPandas Documentation",
      "text": "<p>Welcome to the CubedPandas Documentation site. Here you will find all the information you need to get  started with CubedPandas, a powerful and easy-to-use Python library for working with Pandas dataframes.</p> <p>Note</p> <p>CubedPandas is in an early stage of development, your  Ideas, Issues and  Feedback  are very welcome to make CubedPandas even more awesome. Many thanks!</p>"
    },
    {
      "location": "#olap-comfort-meets-pandas-power",
      "title": "OLAP comfort meets Pandas power!",
      "text": "<p>CubedPandas offer a new easy, fast &amp; fun approach to navigate and analyze Pandas dataframes. CubedPandas is inspired by the powerful concepts of OLAP (Online Analytical Processing) and MDX (Multi-Dimensional Expressions) and aims to bring the comfort and power of OLAP to Pandas dataframes.</p> <p>For novice users, CubedPandas can be a great help to get started with Pandas, as it hides some of the complexity and verbosity of Pandas dataframes. For experienced users, CubedPandas can be a productivity booster, as it allows you to write more compact, readable and maintainable code. Just to give you a first idea, this Pandas code</p> <pre><code># Pandas: calculate the total revenue of all hybrid Audi cars\nvalue = df.loc[(df['make'] == 'Audi') &amp; (df['engine'] == 'hybrid'), 'price'].sum()\n</code></pre> <p>turns into this CubedPandas code</p> <pre><code># CubedPandas: calculate the total revenue of all hybrid Audi cars\nvalue = df.cubed.Audi.hybrid.price\n</code></pre> <p>As CubedPandas does not duplicate data or modifies the underlying dataframe and does not add any performance penalty - in some cases can even boost Pandas performance by factors - it can be used in production without any concerns and should be of great help in many use cases.</p> <p>In Jupyter notebooks, CubedPandas will really start to shine. For further information, please visit the CubedPandas Documentation or try the included samples.</p>"
    },
    {
      "location": "#getting-started",
      "title": "Getting Started",
      "text": "<p>CubedPandas is available on pypi.org (https://pypi.org/project/cubedpandas/) and can be installed by</p> <pre><code>pip install cubedpandas\n</code></pre> <p>Using CubedPandas is as simple as wrapping any Pandas dataframe into a cube like this:</p> <pre><code>import pandas as pd\nfrom cubedpandas import cubed\n\n# Create a dataframe with some sales data\ndf = pd.DataFrame({\"product\":  [\"Apple\",  \"Pear\",   \"Banana\", \"Apple\",  \"Pear\",   \"Banana\"],\n                   \"channel\":  [\"Online\", \"Online\", \"Online\", \"Retail\", \"Retail\", \"Retail\"],\n                   \"customer\": [\"Peter\",  \"Peter\",  \"Paul\",   \"Paul\",   \"Mary\",   \"Mary\"  ],\n                   \"mailing\":  [True,     False,    True,     False,    True,     False   ],\n                   \"revenue\":  [100,      150,      300,      200,      250,      350     ],\n                   \"cost\":     [50,       90,       150,      100,      150,      175     ]})\n\ncdf = cubed(df)  # Wrapp your dataframe into a cube and start using it!\n</code></pre> <p>CubedPandas automatically infers a multi-dimensional schema from your Pandas dataframe which  defines a virtual Cube over the dataframe. By default, numeric columns of the dataframe  are considered as Measures - the numeric values to analyse &amp; aggregate - all other columns are  considered as Dimensions - to filter, navigate and view the data. The individual values in a  dimension column are called the Members of the dimension. In the example above, column <code>channel</code> becomes a dimension with the two members <code>Online</code> and <code>Retail</code>, <code>revenue</code> and <code>cost</code> are our measures.</p> <p>Although rarely required, you can also define your own schema. Schemas are quite powerful and flexible,  as they will allow you to define dimensions and measures, aliases and (planned for upcoming releases) also custom aggregations, business logic, number formating, linked cubes (star-schemas) and much more.</p>"
    },
    {
      "location": "#context-please-so-i-will-give-you-data",
      "title": "Context please, so I will give you data!",
      "text": "<p>One key feature of CubePandas is an easy &amp; intuitive access to individual Data Cells in multi-dimensional data space. To do so, you'll need to define a multi-dimensional Context so CubedPandas will evaluate, aggregate (<code>sum</code> by default) and return the requested value from  the underlying dataframe.</p> <p>Context objects behave like normal numbers (float, int), so you can use them directly in arithmetic operations. In the following examples, all addresses will refer to the exactly same rows from the dataframe and thereby all return the same value of <code>100</code>. </p> <pre><code># Let Pandas set the scene...\na = df.loc[(df[\"product\"] == \"Apple\") &amp; (df[\"channel\"] == \"Online\") &amp; (df[\"customer\"] == \"Peter\"), \"revenue\"].sum()\n\n# Can we do better with CubedPandas? \nb = cdf[\"product:Apple\", \"channel:Online\", \"customer:Peter\"].revenue  # explicit, readable, flexible and fast  \nc = cdf.product[\"Apple\"].channel[\"Online\"].customer[\n    \"Peter\"].revenue  # ...better, if column names are Python-compliant  \nd = cdf.product.Apple.channel.Online.customer.Peter.revenue  # ...even better, if member names are Python-compliant\n\n# If there are no ambiguities in your dataframe - what can be easily checked - then you can use this shorthand forms:\ne = cdf[\"Online\", \"Apple\", \"Peter\", \"revenue\"]\nf = cdf.Online.Apple.Peter.revenue\ng = cdf.Online.Apple.Peter  # as 'revenue' is the default (first) measure of the cube, it can be omitted\n\nassert a == b == c == d == e == f == g == 100\n</code></pre> <p>Context objects also act as filters on the underlying dataframe. So you can use also CubedPandas for fast and easy filtering only, e.g. like this:</p> <pre><code>df = df.cubed.product[\"Apple\"].channel[\"Online\"].df\ndf = df.cubed.Apple.Online.df  # short form, if column names are Python-compliant and there are no ambiguities\n</code></pre>"
    },
    {
      "location": "#pivot-drill-down-slice-dice",
      "title": "Pivot, Drill-Down, Slice &amp; Dice",
      "text": "<p>The Pandas pivot table is a very powerful tool. Unfortunately, it is quite verbose and very hard to master. CubedPandas offers the <code>slice</code> method to create pivot tables in a more intuitive and easy way, e.g. by default</p> <pre><code># Let's create a simple pivot table with the revenue for dimensions products and channels\ncdf.slice(rows=\"product\", columns=\"channel\", measures=\"revenue\")\n</code></pre> <p>For further information, samples and a complete feature list as well as valuable tips and tricks, please visit the CubedPandas Documentation.</p>"
    },
    {
      "location": "#your-feedback-ideas-and-support-are-very-welcome",
      "title": "Your feedback, ideas and support are very welcome!",
      "text": "<p>Please help improve and extend CubedPandas with your feedback &amp; ideas and use the  CubedPandas GitHub Issues to request new features and report bugs.  For general questions, discussions and feedback, please use the  CubedPandas GitHub Discussions.</p> <p>If you have fallen in love with CubedPandas or find it otherwise valuable,  please consider to become a sponsor of the CubedPandas project so we  can push the project forward faster and make CubePandas even more awesome.</p> <p>...happy cubing!</p>"
    },
    {
      "location": "404/",
      "title": "404",
      "text": ""
    },
    {
      "location": "404/#sorry-well-add-that-later",
      "title": "Sorry, we'll add that later...",
      "text": "<p>The current focus of development is on the core features of CubedPandas.  Once finished I'll work on this documention...</p> <p>!!! Note:     To stay tuned for updates and new releases of CubePandas,      please add a watch to the CubedPandas GitHub repo.         </p> <p>Thomas</p>"
    },
    {
      "location": "become-a-sponsor/",
      "title": "Become a sponsor",
      "text": ""
    },
    {
      "location": "become-a-sponsor/#sorry-well-add-that-later",
      "title": "Sorry, we'll add that later...",
      "text": "<p>The current focus of development is on the core features of CubedPandas.  Once finished I'll work on this documention...</p> <p>!!! Note:     To stay tuned for updates and new releases of CubePandas,      please add a watch to the CubedPandas GitHub repo.         </p> <p>Thomas</p>"
    },
    {
      "location": "best-practises/",
      "title": "Best practises",
      "text": ""
    },
    {
      "location": "best-practises/#sorry-well-add-that-later",
      "title": "Sorry, we'll add that later...",
      "text": "<p>The current focus of development is on the core features of CubedPandas.  Once finished I'll work on this documention...</p> <p>!!! Note:     To stay tuned for updates and new releases of CubePandas,      please add a watch to the CubedPandas GitHub repo.         </p> <p>Thomas</p>"
    },
    {
      "location": "blog001_why_cpd/",
      "title": "Blog001 why cpd",
      "text": ""
    },
    {
      "location": "blog001_why_cpd/#sorry-well-add-that-later",
      "title": "Sorry, we'll add that later...",
      "text": "<p>The current focus of development is on the core features of CubedPandas.  Once finished I'll work on this documention...</p> <p>!!! Note:     To stay tuned for updates and new releases of CubePandas,      please add a watch to the CubedPandas GitHub repo.         </p> <p>Thomas</p>"
    },
    {
      "location": "faq/",
      "title": "FAQ",
      "text": ""
    },
    {
      "location": "faq/#for-whom-is-cubedpandas-intended",
      "title": "For whom is CubedPandas intended?",
      "text": "<p>CubedPandas is intended to be useful for every Pandas user. From novice Pandas users or even non-tech business users, to overcome the complexity of Pandas, up to experienced Pandas experts, who want to speed up their data analysis tasks.</p> <p>Another strength of CubedPandas is the support for multi-dimensional OLAP-style data analysis, which is often used for financial data analysis, business intelligence, and reporting.</p>"
    },
    {
      "location": "faq/#is-cubedpandas-free-to-use",
      "title": "Is CubedPandas free to use?",
      "text": "<p>Yes, CubedPandas is free to use. CubedPandas is licensed under the permissive MIT License. You can use it for commercial and non-commercial projects. You can also modify the source code and distribute it under the same license.</p>"
    },
    {
      "location": "faq/#how-can-i-contribute-to-cubedpandas",
      "title": "How can I contribute to CubedPandas?",
      "text": "<p>You can contribute to CubedPandas by reporting bugs, suggesting new features, or by contributing code. Please use the CubedPandas GitHub Issues Page to report bugs and suggest new features. If you would like to contribute code, please fork the CubedPandas GitHub repo and create a pull request.</p>"
    },
    {
      "location": "faq/#is-cubedpandas-ready-for-production-use",
      "title": "Is CubedPandas ready for production use?",
      "text": "<p>No not yet, CubedPandas is still in the early PRE-ALPHA stages of development. Features are being added and changed frequently. Bugs are still likely to be present, when using CubedPandas on real-world data sets. But, it's already possible to use CubedPandas for evaluation and simple data analysis tasks. If you experience any bugs it would be of great help to report them on the CubedPandas GitHub Issues Page.</p>"
    },
    {
      "location": "getting-started/",
      "title": "Getting started with CubedPandas",
      "text": "<p>This guide will help you to get started with CubedPandas. It explains the concept and basic usage and capabilities of CubedPandas.</p> <ul> <li>Getting started with CubedPandas<ul> <li>1. Installation</li> <li>2. The Basic Concept of Cubed Pandas<ul> <li>2.1 Multi-Dimensional Cubes</li> <li>2.2 Interact With Data To Minimize Distraction<ul> <li>2.2.1 Using the . operator</li> <li>2.2.1 Using the [...] operator</li> </ul> </li> </ul> </li> <li>3. The Basic Concepts of CubedPandas<ul> <li>3.1 Context = Data Cell = Numerical Value</li> <li>3.2 Aggregation Function Calls</li> <li>3.3 Context Objects Behave Like Numerical Values</li> <li>3.4 CubedPandas Data Types are Python Data Types</li> <li>3.5 Context Objects Are Lazy</li> <li>3.6 Context Reuse Can Speed Up Your Code</li> <li>3.7 Key Error Handling</li> <li>3.8 Boolean Dimensions</li> </ul> </li> </ul> </li> </ul>"
    },
    {
      "location": "getting-started/#1-installation",
      "title": "1. Installation",
      "text": "<p>CubedPandas is available via PyPI.org and can be installed via pip. It is recommended to always use the latest version of CubedPandas, as CubedPandas is still under constant development, new features are added frequently and know bugs get fixed.</p> <pre><code>pip install cubedpandas\n</code></pre>"
    },
    {
      "location": "getting-started/#2-the-basic-concept-of-cubed-pandas",
      "title": "2. The Basic Concept of Cubed Pandas",
      "text": "<p>The main purpose of CubedPandas is to make working with Pandas easier and more intuitive, ideally also more fun. As DataFrames are two-dimensional structures (tables), it is not always easy to access data in a way that is close to our natural human way of thinking and analysing data. Therefore, CubedPandas introduces 2 main concepts:</p>"
    },
    {
      "location": "getting-started/#21-multi-dimensional-cubes",
      "title": "2.1 Multi-Dimensional Cubes",
      "text": "<p>CubedPandas borrows/mimics the concept of multi-dimensional cubes from OLAP (Online Analytical Processing) databases and brings it to Pandas DataFrames. OLAP-style addressing of data is very close to our natural way of thinking and data analysis, e.g. Sales last year for trucks in North America. is a very natural way to ask for data.</p> <p>CubedPandas automatically infers a multi-dimensional schema from your Pandas DataFrame which then represents a virtual multi-dimensional Cube over the dataframe. By default, all numeric columns of the DataFrame are considered as Measures - the numeric values to analyse &amp; aggregate - all other columns are considered as Dimensions - to filter, navigate and view the data. The individual distinct values in a dimension column are called the Members of the dimension.</p> Converting a Pandas DataFrame into a CubedPandas Cube<pre><code>import pandas as pd\nfrom cubedpandas import cubed\n\n# Create a Pandas dataframe with some sales data\ndf = pd.DataFrame(\n    {\"product\":  [\"Apple\",  \"Pear\",   \"Banana\", \"Apple\",  \"Pear\",   \"Banana\"],\n     \"channel\":  [\"Online\", \"Online\", \"Online\", \"Retail\", \"Retail\", \"Retail\"],\n     \"customer\": [\"Peter\",  \"Peter\",  \"Paul\",   \"Paul\",   \"Mary\",   \"Mary\"  ],\n     \"date\":     [\"2023/12/09\",\"2024/04/16\",\"2024/06/05\",\"2024/06/27\",\"2024/08/21\",\"2024/09/07\"],\n     \"mailing\":  [True,     False,    True,     False,    True,     False   ],\n     \"sales\":    [100,      150,      300,      200,      250,      350     ],\n     \"cost\":     [50,       90,       150,      100,      150,      175     ]})\n\ncdf = cubed(df)  # Turn your dataframe into a CubedPandas cube.\n</code></pre> <p>In the above example, <code>cdf</code> wraps the DataFrame into a 6-dimensional cube with the following dimensions, individual members and measures</p> <ol> <li>Dimension product with members Apple, Pear, Banana</li> <li>Dimension channel with members Online, Retail</li> <li>Dimension customer with members Peter, Paul, Mary</li> <li>Dimension date with members 2023/12/09, 2024/04/16, 2024/06/05, 2024/06/27, 2024/08/21, 2024/09/07</li> <li> <p>Dimension mailing with members True, False</p> </li> <li> <p>Measure revenue with values 100, 150, 300, 200, 250, 350</p> </li> <li>Measure cost with values 50, 90, 150, 100, 150, 175</li> </ol> <p>The basic idea of CubedPandas is to access aggregated data through filtering the data by specific dimension and members for a specific measure of the cube. Example:</p> <pre><code>assert(cdf.Apple.Online.sales == 100)\n</code></pre> <p>The previous statement will (try to) filter the DataFrame by <code>product = \"Apple\"</code>and <code>channel = \"Online\"</code>. All records that match both conditions are then aggregated by the <code>sales</code> measure. As there is only one record that matches both conditions, the result will be <code>100</code>. So the statement is identical to the following Pandas and, for reference, SQL statements:</p> <pre><code>assert(df[(df[\"product\"] == \"Apple\") &amp; (df[\"channel\"] == \"Online\")][\"sales\"].sum() == 100)\n</code></pre> <pre><code>SELECT SUM(sales) FROM df WHERE product = \"Apple\" AND channel = \"Online\" \n</code></pre> <p>The default aggregation function is <code>sum</code>, but can be changed to any other aggregation function, e.g. <code>mean</code>, <code>median</code>, <code>count</code>, <code>max</code>, <code>min</code>, <code>std</code>, <code>var</code> and others. For example: <code>cdf.Apple.Online.sales.mean</code> will return the mean of all sales records that match the conditions <code>product = \"Apple\"</code> and <code>channel = \"Online\"</code>.</p>"
    },
    {
      "location": "getting-started/#22-interact-with-data-to-minimize-distraction",
      "title": "2.2 Interact With Data To Minimize Distraction",
      "text": "<p>The second main concept of CubedPandas is to make access to data as easy, intuitive and destruction free as possible. To minimize syntax and coding CubedPandas introduces the concept of a Context. A context references a single artefact or definition in the cube, e.g. a measure, a dimension, a measure, a filter etc. Multiple contexts can then be combined or 'chained' to form a more complex context. In programming this concept is well known and called method chaining or fluent interface (link), in CubedPandas we call this \"building a Context\".</p> <p>Whatever you will type, CubedPandas will try to resolve it into a context object. Let's assume you want to access:</p> <pre><code>cdf = cubed(df)             # this method returns a Cube object\nsales = cdf.Apple.sales     # this method returns a valid Context object\n</code></pre> <p>In the previous code fragment <code>cdf</code> is a CubedPandas <code>Cube</code> object instance and the root for all further addressing and/or filtering using objects Context objects. Context objects can be defined/accessed in two ways:</p>"
    },
    {
      "location": "getting-started/#221-using-the-operator",
      "title": "2.2.1 Using the <code>.</code> operator",
      "text": "<p>By adding the <code>.</code> operator followed by a Python-compliant attribute name, e.g. <code>cdf.Apple</code> or <code>cdf.sales</code>. As neither <code>Apple</code> nor <code>sales</code> are existing attributes/keywords of the Cube object, CubedPandas will try to resolve them as measure, dimension or member names of the cube. If the resolution is successful, a new Context object is created and returned. If the resolution fails, an error is raised. Further chaining can be applied to create a subsequent context t, e.g. <code>cdf.Apple.sales</code> or <code>cdf.Apple.Online.sales</code>, there is virtually no limitation in depth and length of chaining.</p> <p>Wait, wait, wait! What happens if a measure, dimension or member are not a Python-compliant attribute names or even conflict with python keywords? E.g. <code>cdf.sales rep</code>, <code>cdf.True</code> or <code>cdf.2024/08/21</code> are reserved or invalid Python attribute names. In this case you can use the <code>[]</code> operator as explained below or leverage the various hacks that are build into CubedPandas to resolve such conflicts.</p> <p>Caution</p> <p>Please be aware that all attribute names are case-sensitive. Measure, dimension and member names must be written exactly as they are contained in the DataFrame. You can use the <code>members</code> property of a dimension context to get a list of all members of the dimension. But this also means that 'Apple' is not the same as 'apple' or 'APPLE'. For future releases of CubedPandas it is planned to provide a all-lower-case option to resolve such case specific issues, typos and confusion.</p> <p>A few examples of how some, not all, naming conflicts can be resolved:</p> <pre><code>a = cdf.sales_rep  # use underscores to replace whitespaces \"sales rep\" := \"sales_rep\"\na = cdf.true       # use lower case for upper case Python Keywords like True or False \na = cdf.And        # use upper case for lower case Python Keywords like and, or, not\n</code></pre>"
    },
    {
      "location": "getting-started/#221-using-the-operator_1",
      "title": "2.2.1 Using the <code>[...]</code> operator",
      "text": "<p>The <code>[]</code> operator is the much more flexible and safe way to access and define Context objects. It allows you to access measures, dimensions and members which arbitrary names, e.g. <code>cdf[\"sales rep\"]</code>, or any data type, e.g. <code>cdf[True]</code> or <code>cdf[datetime.now()]</code>. Whatever you throw into the <code>[]</code> operator, CubedPandas will try to resolve it into a Context object. If the resolution fails, a (hopefully meaningful) <code>ValueError</code> is raised so you can correct your code.</p> <p>A few examples of how the <code>[]</code> operator can be used:</p> <ul> <li><code>a = cdf.product[\"Apple\"].sales</code>    This, using a <code>.</code> separated keyword for dimension and measure names and the <code>[]</code> operator for member names,   is the most explicit, readable and fastest way to address/access/filter data.   It is recommended to use this form whenever possible!</li> <li><code>cdf.product[\"Apple\"]</code>   The keyword for the 'sales' measure can be omitted if yoiu want to access the default measure of the cube.   By default, this is the first measure, from left to right, of the cube.</li> <li><code>a = cdf[\"Apple\"]</code>   This is less explicit, and you might run into ambiguities if the same value is contained in multiple   dimensions of the Cube. Also, as no dimension is specified, CubedPandas needs to investigate all dimensions   to find the member <code>Apple</code>. For large DataFrames with high member cardinality, this can become slow.</li> <li><code>cdf[True]</code>   Here we are using a boolean value as a member of a dimension. CubedPandas will try to resolve it as a member   from all dimensions of the cube that do or could contain boolean values. If the resolution is successful,   a Context will be returned. So, this statement is identical to <code>cdf.mailing[True]</code> as mailing is the only   dimension that contains boolean values.</li> <li><code>cdf[datetime.now()]</code>   Same example as the previous one, but now we are using a datetime object as a member of a dimension.   CubedPandas will resolve the <code>date</code> dimension and try to find the member that matches the current date.   So, this statement is identical to <code>cdf.date[datetime.now()]</code>.</li> </ul>"
    },
    {
      "location": "getting-started/#3-the-basic-concepts-of-cubedpandas",
      "title": "3. The Basic Concepts of CubedPandas",
      "text": "<p>In this chapter, we will present and explain all the basic concepts and conventions of CubedPandas.</p>"
    },
    {
      "location": "getting-started/#31-context-data-cell-numerical-value",
      "title": "3.1 Context = Data Cell = Numerical Value",
      "text": "<p>When you build a context, e.g. <code>cdf.product.Apple.sales</code>, it always refers to a single data cell in the multi-dimensional data space. Each cell represents a single numerical value, which is the aggregation of all records in the DataFrame that match the conditions defined by the context. The default and most used aggregation function is <code>sum</code>, therefore it can be omitted and the following 3 statements are identical:</p> <pre><code>a = cdf.product.Apple.sales\nb = cdf.product.Apple.sales.sum\nc = cdf.product.Apple.sales.sum()\nassert(a == b == c)\n</code></pre>"
    },
    {
      "location": "getting-started/#32-aggregation-function-calls",
      "title": "3.2 Aggregation Function Calls",
      "text": "<p>Please note that the <code>()</code> operator in the sample above is optional to return a value from the context. This due to fact that all aggregation functions are context objects by themselves. Using <code>()</code> to call the method will terminate the context chain and return simple a numerical value, whereas omitting the <code>()</code> method call will return a context object that can be further chained or used in other contexts.</p> <pre><code>a = cdf.product.Apple.sales.sum     # returns a context object that can be further chained \n                                    # and behaves as a numerical value (float or int) at the same time\nb = cdf.product.Apple.sales.sum()   # returns just a numerical value (float or int)\n\nc = a.Online  # Will return the sales of Apple for the Online channel.\nd = b.Online  # Will RAISE AN ERROR, as `b` is of type int or float.\n</code></pre>"
    },
    {
      "location": "getting-started/#33-context-objects-behave-like-numerical-values",
      "title": "3.3 Context Objects Behave Like Numerical Values",
      "text": "<p>All context objects behave like numerical values, so you can use them in any numerical operation, some examples:</p> <pre><code>a = cdf.product.Apple.sales\nb = cdf.product.Pear.sales\navg_sales = (a + b) / cdf.product.Apple.Pear.count  # note: count returns the number of records\nassert(avg_sales == cdf.product.Apple.Pear.sales.mean)\n</code></pre> <p>Please note that aggregation functions like <code>sum</code>, <code>max</code>, <code>min</code> return the same data type as from the underlying DataFrame. Whereas <code>mean</code>, <code>median</code>, <code>std</code>, <code>var</code> return a float and <code>count</code>, <code>nunique</code> etc. return an integer.</p>"
    },
    {
      "location": "getting-started/#34-cubedpandas-data-types-are-python-data-types",
      "title": "3.4 CubedPandas Data Types are Python Data Types",
      "text": "<p>Other than Pandas, CubedPandas will always convert all data Pandas and Numpy specific datatypes to the respective Python datatypes. This means, that all data types are either <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, <code>datetime</code>, <code>date</code> or <code>time</code>. This makes it easier to work with the data in CubedPandas, as you don't need to worry about the specific Pandas or Numpy data types.</p>"
    },
    {
      "location": "getting-started/#35-context-objects-are-lazy",
      "title": "3.5 Context Objects Are Lazy",
      "text": "<p>CubedPandas evaluates the actual value of a context object only when it is needed. This means that when you can build a multipart context object like <code>cdf.product.Apple.channel.Online.sales</code> then only the filtering for each individual context object in the chain is evaluated. In addition, the filtering is subsequently applied to the DataFrame, so the first context object in the chain needs to filter all records of the DataFrame. The subsequent context objects in the chain then only need to filter the records that are already filtered by the previous context objects.</p> <p>Tip</p> <p>If you filter on the most selective dimension first, you might be able to speed up the filtering process quite a bit.</p> <p>Evaluation of the actual value of a context object is only done when the context object is used in a numerical operation or when used otherwise as a numerical value, e.g. for printing or showing the value while debugging.</p>"
    },
    {
      "location": "getting-started/#36-context-reuse-can-speed-up-your-code",
      "title": "3.6 Context Reuse Can Speed Up Your Code",
      "text": "<p>If you need to access data from a certain area of the cube multiple times, it is recommended to store the context object in a variable. This will prevent the re-evaluation of the context object and speed up your code. The following code fragment shows how to iterate over all products that Peter bought Online.</p> <pre><code>online_sales_with_peter = cdf.channel.Online.customer.Peter.sales\nfor member in online_sales_with_peter.product.members:\n    print(f\"Sales of {member} with Peter: {online_sales_with_peter[member]}\")\n</code></pre>"
    },
    {
      "location": "getting-started/#37-key-error-handling",
      "title": "3.7 Key Error Handling",
      "text": "<p>By default, CubedPandas will raise a <code>KeyError</code> if a measure, dimension or member name can not be found in the DataFrame. This is to help to detect typos and errors easily.</p> <p>If you want to suppress ALL key errors, you can set the <code>ignore_key_errors</code> attribute to <code>True</code> either when you create a <code>Cube</code> object, e.g. <code>cdf = cubed(df, ignore_key_errors=True)</code>, or through the <code>cube.settings</code>object. Doing so, all requests against non-existing measure, dimension or member names will return <code>None</code> or <code>0</code> instead of raising an error.</p> <p>Wether <code>None</code> or <code>0</code> will be returned depends on the context, but mainly the value of the <code>return_none_for_non_existing_cells</code> setting (default value is <code>False</code>) of the Cube object. So be default, <code>0</code> will be returned for non-existing cells, but you can change this behaviour by setting the attribute to <code>True</code>.</p> <pre><code>cdf = cubed(df)             \nfail = cdf.xyz123.sales     # This will RAISE AN ERROR as 'xyz123'   \n                            # is not a valid measure, dimension or member name\n\ncdf.settings.ignore_key_errors = True\nno_fail = cdf.xyz123.sales  # This will return `0.0` as 'xyz123' does not exist in the DataFrame\n\ncdf.settings.return_none_for_non_existing_cells = True\nno_fail = cdf.xyz123.sales  # Now it will return `None` \n</code></pre> <p>If you want to suppress key errors for members only, you can set the <code>ignore_member_key_errors</code> attribute to <code>True</code>. This will suppress key errors for member names only, but not for measure or dimension names. This approach is recommended if you want check for specific members in a dimension, but you are unsure if the exist and don't want to raise an error if the member does not exist.</p> <pre><code>cdf = cubed(df)\nfail = cdf.product.xyz123.sales     # This will RAISE AN ERROR as 'xyz123'   \n                                    # is not a valid member name of the 'product' dimension\n\ncdf.settings.ignore_member_key_errors = True\nno_fail = cdf.product.xyz123.sales  # This will return `0.0` as 'xyz123' is not contained in the 'product' dimension\nfail = cdf.xyz123.sales             # This will RAISE AN ERROR as 'xyz123' \n                                    # is not a valid measure, dimension or member name\n</code></pre> <p>For a future version of CubedPandas, it is planned to add individual behaviours for key-errors per dimension into the schema. This will allow you to define if key errors should be ignored for a specific dimension or not.</p>"
    },
    {
      "location": "getting-started/#38-boolean-dimensions",
      "title": "3.8 Boolean Dimensions",
      "text": "<p>If a dimension contains boolean values only (the underlying Pandas DataFrame column is of type <code>bool</code>), CubedPandas will try resolve either the boolean value <code>True</code> or <code>False</code> as the requested member of the dimension.</p> <p>CubedPandas supports various aliases for <code>True</code> and <code>False</code>, e.g. <code>yes</code> and <code>no</code>, <code>on</code> and <code>off</code>, <code>1</code> and <code>0</code>. The following statements are all identical:</p> <pre><code>cdf = cubed(df)\nmailing = cdf.mailing[True].sales\nmailing = cdf.mailing[\"TruE\"].sales\nmailing = cdf.mailing[\"Yes\"].sales\nmailing = cdf.mailing[\"on\"].sales\nmailing = cdf.mailing[1].sales\n</code></pre> <p>As boolean dimensions are quite common in data analysis, CubedPandas assumes that when you use the dimension name only, you are referring to the <code>True</code> member of the dimension. So, <code>cdf.mailing.sales</code> is identical to <code>cdf.mailing[True].sales</code> and the <code>[True]</code> argument can be omitted.</p>"
    },
    {
      "location": "installation/",
      "title": "Installation",
      "text": ""
    },
    {
      "location": "installation/#cubedpandas-installation",
      "title": "CubedPandas Installation",
      "text": "<p>As always with Python packages, the easiest way to install CubedPandas is by using <code>pip</code>.</p> <pre><code>pip install cubedpandas\n</code></pre> <p>It is recommended to always use the latest version of CubedPandas, as CubedPandas is still under constant development, new features are added frequently and know bugs get fixed.</p> <p>You will find the latest version of CubedPandas on PyPi.org. Alternatively, you can clone the CubedPandas GitHub repo and build it on your own or integrate somehow in your own project. Please check the requirements.txt file for the required dependencies.</p>"
    },
    {
      "location": "license/",
      "title": "License",
      "text": "<p>CubedPandas is licensed under the permissive MIT License. You can use it for commercial and non-commercial projects. You can also modify the source code and distribute it under the same license.</p> <pre><code>MIT License\n\nCopyright (c) 2024, Thomas Zeutschler\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"
    },
    {
      "location": "readme_mkdocs/",
      "title": "CubedPandas website &amp; documentation how-to guide",
      "text": "<p>by Thomas Zeutschler, June 2024</p>"
    },
    {
      "location": "readme_mkdocs/#introduction",
      "title": "Introduction",
      "text": "<p>The CubedPandas website &amp; documentation is made with MkDocs. MkDocs is a static site generator that creates a website from markdown files and from the actual source code of the project. The CubedPandas website will  be hosted on GitHub pages: https://zeutschler.github.io/cubedpandas/.</p> <p>The documentation is structured as follows:</p> <ul> <li>Homepage - Short Intro to CubedPandas, features, installation, sample code, etc.</li> <li>User documentation - The documentation will be used to explain the usage of the tool to the users.</li> <li>Developer documentation - The documentation will be used to explain the architecture and the design of the tool   to developers.</li> <li>Blog - Posts and news about CubedPandas features, development, best practices, etc.</li> </ul>"
    },
    {
      "location": "readme_mkdocs/#how-to-build-the-documentation",
      "title": "How to build the documentation",
      "text": "<p>The documentation can be built by using the <code>mkdocs</code> command line tool from the root directory of the project: </p> <pre><code>mkdocs build --clean --site-dir 'pages/'\n</code></pre>"
    },
    {
      "location": "readme_mkdocs/#how-to-run-and-view-the-documentation-locally",
      "title": "How to run and view the documentation locally",
      "text": "<p>The documentation can be run and viewed locally by using the <code>mkdocs</code> command line tool from the root  directory of the project <pre><code>mkdocs serve\n</code></pre> This will start a local web server that serves the documentation. Edits to the markdown files will be automatically reloaded in the browser. The documentation is the available at the following URL:</p> <p><pre><code>http://127.0.0.1:8000/data-model-generator/\n</code></pre> To stop the local web server, press <code>CTRL+C</code> in the command line tool. That's all, enjoy!</p> <p>Additional information on how to use MkDocs can be found in the MkDocs documentation and in the following guide RealPython: Build Your Python Project Documentation With MkDocs.</p>"
    },
    {
      "location": "use-cases/",
      "title": "Use Cases for CubedPandas",
      "text": "<p>CubedPandas is a general purpose library to simplify and speed up data analysis with Pandas dataframes. Here are some use cases and examples, where CubedPandas can be particularly useful and valuable.</p>"
    },
    {
      "location": "use-cases/#1-support-for-novice-pandas-users",
      "title": "1. Support for Novice Pandas Users",
      "text": "<p>For novice users, CubedPandas can be a great help to get started with Pandas, as it hides some of the complexity and verbosity of working with Pandas dataframes. Especially for business users and citizen data analysts, who are not so familiar with Programming, CubedPandas can be much less intimidating than using Pandas. Example</p> <pre><code># Pandas - programming language\nvalue = df.loc[(df['make'] == 'Audi') &amp; (df['engine'] == 'hybrid'), 'price'].sum()\n\n# CubedPandas - (more like) business language \nvalue = df.cubed.Audi.hybrid.price\n</code></pre>"
    },
    {
      "location": "use-cases/#2-productivity-booster-for-experienced-pandas-users",
      "title": "2. Productivity Booster for Experienced Pandas Users",
      "text": "<p>For experienced users, CubedPandas can be a great productivity booster, as it allows to write more compact, readable and maintainable code. Some experts use it just to speed up their data filtering. Example:</p> <pre><code># Let's assume you have a data file with a 'changed' column, \n# containing timestamps like '2024-06-18T12:34:56'.\n# To get all records that 'changed' yesterday using  \n# Pandas you would need to write something like this:\ndf = pd.read_csv('data.csv')\ndf['changed'] = pd.to_datetime(df['changed'])\ndf = df[df['changed'].dt.date == pd.Timestamp.now().date() - pd.Timedelta(days=1)]\n\n# Using CubedPandas you can write:\ndf = pd.read_csv('data.csv').cubed.changed.yesterday.df    \n# Note: Common English date phrases like today, yesterday, last_hour or lasthour, \n#       lastweek, lastmonth, last_year, next_month etc. will be resolved automatically.\n</code></pre>"
    },
    {
      "location": "use-cases/#3-financial-data-analysis-reporting",
      "title": "3. Financial Data Analysis &amp; Reporting",
      "text": "<p>When it's all about the aggregation of financial and business data, CubedPandas really shines. As multi-dimensional addresses are very close to our natural way of thinking, CubedPandas is a perfect fit for reporting, business intelligence and even (minimal) data warehousing.</p> <p>First, CubePandas provides direct and intuitive access to aggregated figures, e.g.:</p> <pre><code>c = cubed(df)\ntrucks = c.region.North_America.sbu.Trucks.sales\ndelta_percent = (trucks.this_year - trucks.last_year) / trucks.last_year\nif delta_percent &gt; 0.1:\n    # do something\n    ...\n</code></pre> <p>Second, CubedPandas can be used to create reports and pivot-tables, e.g., you can easily create a pivot table with the total sales per region and product:</p> <pre><code># Create a simple pivot table based on the above 'truck' filter with\n# 'salesrep' and 'customer' in the rows and the last and \n# actual month sales in the columns. The 'sales' measure was already defined in trucks\ntrucks.slice(rows=c.salesrep &amp; c.customer, columns=c.lastmonth &amp; c.actualmonth)\n</code></pre> <p>CubedPandas automatically adds totals and sub-totals to the pivot table (not an easy task with Pandas alone) and also apply some basic formatting. More advanced pivot-table features and also a set of standard data analysis can/will be added in the future, if there is demand for such capabilities.</p>"
    },
    {
      "location": "use-cases/#4-data-quality-analysis",
      "title": "4. Data Quality Analysis",
      "text": "<p>CubedPandas is also a great tool for data quality analysis. Due to the cell based data access,  expected totals, missing values, duplicates, and other data quality issues can be easily checked.</p> <pre><code>c = cubed(pd.read_csv('daily_delta.csv'))\nany_nan_in_cube = c.NAN.any\nmissing_values_count = c.revenue.NAN.count\nsuspicious_records = c[c.revenue_ &lt; c.profit_]    \n</code></pre> <p>Note</p> <p>If you would like to share your own use case for CubedPandas, anonymously or with reference, then please let me know, they'll be added here. Just leave me a comment in the CubedPandas GitHub discussions, or by creating a GitHub issue.</p>"
    },
    {
      "location": "about/contributing/",
      "title": "Contributing",
      "text": "<p>You are very welcome to contribute to CubedPandas by reporting bugs, suggesting new features, or by contributing code. Please use the CubedPandas GitHub Issues Page or the CubedPandas reddit channel to report bugs, suggest new features and give feedback. If you would like to contribute code, please fork the CubedPandas GitHub repo and create a pull request, or join me in pushing the CubedPandas project forward.</p>"
    },
    {
      "location": "about/license/",
      "title": "License",
      "text": "<p>CubedPandas is licensed under the permissive MIT License. You can use it for commercial and non-commercial projects. You can also modify the source code and distribute it under the same license.</p> <pre><code>MIT License\n\nCopyright (c) 2024, Thomas Zeutschler\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"
    },
    {
      "location": "about/release-notes/",
      "title": "Release Notes",
      "text": ""
    },
    {
      "location": "about/release-notes/#release-02x-current-scope-of-work",
      "title": "Release 0.2.x (Current Scope of Work)",
      "text": "<ul> <li>[ ] Rewrite documentation based on new syntax and current feature set.</li> <li>[ ] Slice to support and resolve boolean operations to define row and colum dimensions in a single step.   e.g. <code>trucks.slice(rows=c.salesrep &amp; c.customer, columns=c.lastmonth &amp; c.actualmonth)</code></li> <li>[ ] Support callable function to filter Context objects, e.g. <code>cdf.product.filter(lambda x: x.startswith(\"A\"))</code>.</li> <li>[ ] Collect real-world data sets for testing and validation and implement an automated tester for any dataframe.</li> </ul>"
    },
    {
      "location": "about/release-notes/#release-03x",
      "title": "Release 0.3.x",
      "text": "<ul> <li>[ ] <code>address</code> property to return the fully qualified address to rebuild the full context from that address.</li> <li>[ ] add individual behaviours for key-errors per dimension into schema</li> <li>[ ] Extend Expression Parser to support more advanced filtering and mathematical operations on <code>Context</code> objects.</li> </ul>"
    },
    {
      "location": "about/release-notes/#future-releases",
      "title": "Future Releases",
      "text": "<p>Just ideas, neither decided, nore scheduled or prioritized.</p> <ul> <li>[ ] Support for Linked Cubes to mimic DWH-style star-schemas.</li> <li>[ ] Custom Business Logic: Allow users to define custom business logic for measures.</li> <li>[ ] Custom Measures: Allow users to define custom measures.</li> <li>[ ] Custom Dimensions: Allow users to define custom calculated dimensions.</li> <li>[ ] Custom Members: Allow users to define custom calculated members.</li> </ul>"
    },
    {
      "location": "about/release-notes/#implemented-features-issue-bugs",
      "title": "Implemented Features, Issue, Bugs",
      "text": ""
    },
    {
      "location": "about/release-notes/#release-02x",
      "title": "Release 0.2.x",
      "text": "<ul> <li>[x] Date,time and Datetime resolvers for Englisch keywords like <code>yesterday</code>, <code>today</code>, <code>tomorrow</code>, <code>lastweek</code>,   <code>thisweek</code>, <code>nextweek</code>, <code>lastmonth</code>, <code>thismonth</code>, <code>nextmonth</code>, <code>lastyear</code>, <code>thisyear</code>, <code>nextyear</code> etc.   as members of a dimension. Multiple words should either be written together or separated by <code>_</code>,   e.g. <code>last_month</code> vs. <code>lastmonth</code>.</li> <li>[x] All member related functions should return a list of the member keys as defined in the dataframe.   Not wrapped into a <code>Member</code> object.</li> <li>[x] Support for <code>in</code> operator on DimensionContext</li> <li>[x] add feature/switch to return None vs. 0 for data without records.</li> <li>[x] <code>true</code> &amp; <code>false</code> as members of a dimension should be resolved as <code>True</code> and <code>False</code> respectively.   Aliases to be supported <code>yes</code> &amp; <code>no</code> and <code>on</code> &amp; <code>off</code> and <code>1</code> &amp; <code>0</code> if used via index.</li> <li>[x] Support callable methods for all aggregation functions, e.g. <code>sum</code> -&gt; <code>sum()</code>.   see https://stackoverflow.com/questions/20120983/determine-if-getattr-is-method-or-attribute-call</li> <li>[x] Further Cleanup and rewrite for Cube, Dimension and Measure object.   Move all none essential methods, properties and settings to respective properties,   e.g. <code>Cube.settings</code>, <code>Cube.properties</code>, <code>Cube.methods</code> etc.</li> <li>[x] check string representations for all objects when in running in Jupyter</li> <li>[x] Check, adapt and activate the existing writeback functionality.</li> <li>[x] Implement <code>cdf.product.members</code> property to return a list of all members for a dimension.</li> <li>[x] <code>top(n)</code> and <code>bottom(n)</code> functions for dimensions, e.g. <code>cdf.product.top(2)</code>.</li> <li>[x] <code>count</code> property for dimensions, e.g. <code>cdf.Online.product.count</code>, to count the number of distinct members.   The current implementation counts the records for the default measure.</li> <li>[x] Implement <code>Context.full_address</code> property returning a dictionary.</li> <li>[x] implement 'by(rows, colums)' feature for <code>Context</code> objects to mimic GroupBy functionality over 2 axis.</li> <li>[x] Boolean logic for <code>Contex</code> objects for advanced filtering. <code>and</code> and <code>or</code> operators   for <code>Context</code> objects,<code>and</code> as default.</li> <li>[x] Allow to set the default measure</li> <li>[x] Filter functions for dimensions: include, exclude, filter, like, regex, etc.</li> <li>[x] Filter functions for measures: gt, lt, eq, ne, etc.</li> <li>[x] Data Type Validation for columns</li> <li>[x] Update/rewrite all tests based on new syntax</li> </ul>"
    },
    {
      "location": "about/release-notes/#release-01x",
      "title": "Release 0.1.x",
      "text": "<ul> <li>[x] Initial Release</li> </ul>"
    },
    {
      "location": "about/thomas/",
      "title": "Thomas",
      "text": "<p>My name is Thomas Zeutschler. I'm located in Germany in the 'Ruhrgebiet' area and love to code in Python due to Python's awesome and endless library ecosystem, great support community and easy extensibility through tools like Numba, Cython or with languages like C, C++ and Rust.</p> <p>Pandas is a tool to which I have a strong love/hate relationship. It's a great tool, but sometimes it's annoyingly complex and tedious to use, that's why I started the CubedPandas project.</p> <p>I'm a professional software architect and developer with focus on data, analytics, AI and modern cloud based data architectures and data processing as well as the development, optimization, modernization and especially speed-up of data-focussed solutions and systems of every size and complexity.</p> <p>In addition, I enjoy to be a senior analytics and fellow at the BARC - Business Analytics Research Center in W\u00fcrzburg, Germany. BARC is the largest independent market analyst for data, analytics &amp; AI, business intelligence and corporate performance management in the D-A-CH region. I proudly support mid-sized and large companies in improving their data &amp; analytics capabilities, setup, and strategy. And I am honoured to help some well-known software vendors support their products and go-to-market strategies market strategies in the area of data &amp; analytics.</p> <p>I'm a big fan and intense user of open source software. CubedPandas is one of my projects to say thank you to the community and to give something back. I hope you enjoy using CubedPandas as much as I enjoy developing it.</p> <p>Hobbies? Anything on two wheels, with or without an engine, on-road or off-road is my passion.</p> <p>If you would like to get in contact, do not hesitate to reach out to me on LinkedIn or reddit or GitHub.</p> <p>Yours Thomas</p>"
    },
    {
      "location": "api/class-context/",
      "title": "CubedPandas Context Class",
      "text": "<p>               Bases: <code>SupportsFloat</code></p> <p>A context represents a multi-dimensional data context or area from within a cube. Context objects can be used to navigate and access the data of a cube and thereby the underlying dataframe.</p> <p>Cells behave like Python floats and return a numeric aggregation of the underlying data. They are intended to be used in mathematical operations.</p> Samples <p>cdf = cubed(df) value = cdf.A + cdf.B / 2 200 cdf.A *= 2</p>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.function",
      "title": "<code>function: ContextFunction</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>ContextFunction</code>           \u2013            <p>The aggregation function that will be applied to the current context.</p> </li> </ul>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.value",
      "title": "<code>value</code>  <code>property</code> <code>writable</code>",
      "text": "<p>Returns:</p> <ul> <li>           \u2013            <p>The sum value of the current context from the underlying cube.</p> </li> </ul>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.numeric_value",
      "title": "<code>numeric_value: float</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The numerical value of the current context from the underlying cube.</p> </li> </ul>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.cube",
      "title": "<code>cube: Cube</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>Cube</code>           \u2013            <p>The Cube object the Context belongs to.</p> </li> </ul>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.dimension",
      "title": "<code>dimension: Dimension</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>Dimension</code>           \u2013            <p>The Cube object the Context belongs to.</p> </li> </ul>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.parent",
      "title": "<code>parent: Context</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>Context</code>           \u2013            <p>The parent Context of the current Context. If the current Context is the root Context of the cube,</p> </li> <li> <code>Context</code>           \u2013            <p>then the parent Context will be <code>None</code>.</p> </li> </ul>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.df",
      "title": "<code>df: pd.DataFrame</code>  <code>property</code>",
      "text": "<p>Returns: Returns a new Pandas dataframe with all column of the underlying dataframe of the Cube, but only with the rows that are represented by the current context.</p> <p>The returned dataframe is always a copy of the original dataframe, even if the context is not filtering any rows from the underlying dataframe. The returned dataframe can be used for further processing outside the cube.</p>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.address",
      "title": "<code>address: any</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>any</code>           \u2013            <p>The partial address of the context, as defined by the user</p> </li> <li> <code>any</code>           \u2013            <p>This does not include the addresses defined by predecessor</p> </li> <li> <code>any</code>           \u2013            <p>cells down to the cube.</p> </li> </ul>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.cube_address",
      "title": "<code>cube_address: str</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The full address of the context, including all predecessor</p> </li> <li> <code>str</code>           \u2013            <p>cells down to the cube.</p> </li> </ul>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.measure",
      "title": "<code>measure: Measure</code>  <code>property</code> <code>writable</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>Measure</code>           \u2013            <p>The Measure object the Context is currently referring to.</p> </li> <li> <code>Measure</code>           \u2013            <p>The measure refers to a column in the underlying dataframe</p> </li> <li> <code>Measure</code>           \u2013            <p>that is used to calculate the value of the context.</p> </li> </ul>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.row_mask",
      "title": "<code>row_mask: np.ndarray | None</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>ndarray | None</code>           \u2013            <p>The row mask of the context. The row mask is represented by a Numpy ndarray</p> </li> <li> <code>ndarray | None</code>           \u2013            <p>of the indexes of the rows represented by the current context. The row mask can be used</p> </li> <li> <code>ndarray | None</code>           \u2013            <p>for subsequent processing of the underlying dataframe outside the cube.</p> </li> </ul>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.member_mask",
      "title": "<code>member_mask: np.ndarray | None</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>ndarray | None</code>           \u2013            <p>The member mask of the context. If the context refers to a member or a set of members from a dimension.</p> </li> <li> <code>ndarray | None</code>           \u2013            <p>then a Numpy ndarray containing the indexes of the rows representing the members is returned.</p> </li> <li> <code>ndarray | None</code>           \u2013            <p><code>None</code> is returned otherwise.</p> </li> <li> <code>ndarray | None</code>           \u2013            <p>The row mask can be used for subsequent processing of the underlying dataframe outside the cube.</p> </li> </ul>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.row_mask_inverse",
      "title": "<code>row_mask_inverse: np.ndarray</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The inverted row mask of the context. The inverted row mask is represented by a Numpy ndarray</p> </li> <li> <code>ndarray</code>           \u2013            <p>of the indexes of the rows NOT represented by the current context. The inverted row mask</p> </li> <li> <code>ndarray</code>           \u2013            <p>can be used for subsequent processing of the underlying dataframe outside the cube.</p> </li> </ul>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.__init__",
      "title": "<code>__init__(cube, address, parent=None, row_mask=None, member_mask=None, measure=None, dimension=None, function=ContextFunction.SUM, resolve=True, filtered=False, dynamic_attribute=False)</code>",
      "text": "<p>Initializes a new Context object. For internal use only. Raises:     ValueError:         If the address is invalid and does not refer to a         dimension, member or measure of the cube.</p>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.set_value",
      "title": "<code>set_value(value, allocation_function=ContextAllocation.DISTRIBUTE)</code>",
      "text": "<p>Writes a value to the current context of the cube down to the underlying dataframe. The allocation method can be chosen.</p> <p>Parameters:</p> <ul> <li> <code>value</code>           \u2013            <p>The value to be written to the cube.</p> </li> <li> <code>allocation_function</code>               (<code>ContextAllocation</code>, default:                   <code>DISTRIBUTE</code> )           \u2013            <p>The allocation function to be used for writing the value to the cube.</p> </li> </ul> <p>Returns:     The new value of the current context from the underlying cube.</p>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.top",
      "title": "<code>top(n)</code>",
      "text": "<p>Returns the top n members of the current context. Args:     n:         The number of top members to be returned. Returns:     A list of the top n members of the current context.</p>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.bottom",
      "title": "<code>bottom(n)</code>",
      "text": "<p>Returns the bottom n members of the current context. Args:     n:         The number of bottom members to be returned. Returns:     A list of the bottom n members of the current context.</p>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.__getattr__",
      "title": "<code>__getattr__(name)</code>",
      "text": "<p>Dynamically resolves member from the cube and predecessor cells.</p>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.__getitem__",
      "title": "<code>__getitem__(address)</code>",
      "text": "<p>Returns a nested context of the cube and for a given address. Subsequent nested cells can bee seen as subsequent filters upon the underlying dataframe.</p> <p>Parameters:</p> <ul> <li> <code>address</code>           \u2013            <p>A valid cube address. Please refer the documentation for further details.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A Context object that represents the cube data related to the address</p> </li> <li>           \u2013            <p>and all predecessor cells down to the cube.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the address is not valid or can not be resolved.</p> </li> </ul>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.__setitem__",
      "title": "<code>__setitem__(address, value)</code>",
      "text": "<p>Sets a value for a given address in the cube. Args:     address:         A valid cube address.         Please refer the documentation for further details.     value:         The value to be set for the data represented by the address. Raises:     PermissionError:         If write back is attempted on a read-only Cube.</p>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.__delitem__",
      "title": "<code>__delitem__(address)</code>",
      "text": "<p>Deletes the records represented by the given address from the underlying dataframe of the cube. Args:     address:         A valid cube address.         Please refer the documentation for further details. Raises:     PermissionError:         If write back is attempted on a read-only Cube.</p>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.slice",
      "title": "<code>slice(rows=None, columns=None, config=None)</code>",
      "text": "<p>Returns a new slice for the context. A slice represents a table-alike view to data in the cube. Typically, a slice has rows, columns and filters, comparable to an Excel PivotTable. Useful for printing in Jupyter, visual data analysis and reporting purposes. Slices can be easily 'navigated' by setting and changing rows, columns and filters.</p> <p>Please refer to the documentation of the Slice class for further details.</p> <p>Parameters:</p> <ul> <li> <code>rows</code>           \u2013            <p>The rows of the slice. Can be one or more dimensions with or without a member definition, or no dimension.</p> </li> <li> <code>columns</code>           \u2013            <p>The columns of the slice. Can be one or more dimensions with or without a member definition, or no dimension.</p> </li> <li> <code>filters</code>           \u2013            <p>The filters of the slice. Can be one or more dimensions with or without a member definition, or no dimension.</p> </li> <li> <code>config</code>           \u2013            <p>(optional) A slice configuration as a dictionary, a json string or a path to an existing file containing the configuration. Slice configurations can be used to define a more complex layout. Please refer to the documentation of the Slice class for further details.</p> </li> </ul> Samples <p>cdf = cubed(df) cdf.slice(rows=\"product\", columns=\"region\", filters={\"year\": 2020})</p>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.slice--year-2000",
      "title": "year: 2000",
      "text": ""
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.slice--all-north-south",
      "title": "|         | (all) | North | South |",
      "text": "<p>| (all)   |   550 |   300 |   250 | | Apple   |   200 |   100 |   100 | | Banana  |   350 |   200 |   150 |</p>"
    },
    {
      "location": "api/class-context/#cubedpandas.context.context.Context.filter",
      "title": "<code>filter(filter)</code>",
      "text": "<p>Filters the current context by a given filter expression, criteria or callable function. Args:     filter:         The filter expression, criteria or callable function to be used for filtering the context. Returns:     A new context with the filtered data.</p>"
    },
    {
      "location": "api/class-cube/",
      "title": "CubedPandas Cube Class",
      "text": "<p>Wraps a Pandas dataframes into a cube to provide convenient multi-dimensional access to the underlying dataframe for easy aggregation, filtering, slicing, reporting and data manipulation and write back. A schema, that defines the dimensions and measures of the Cube, can either be inferred automatically from the underlying dataframe (default) or defined explicitly.</p>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.settings",
      "title": "<code>settings: CubeSettings</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>CubeSettings</code>           \u2013            <p>The settings of the Cube.</p> </li> </ul>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.measures",
      "title": "<code>measures: MeasureCollection</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>MeasureCollection</code>           \u2013            <p>The measures available within or defined for the Cube.</p> </li> </ul>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.ambiguities",
      "title": "<code>ambiguities: Ambiguities</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>Ambiguities</code>           \u2013            <p>An Ambiguities object that provides information about ambiguous data types in the underlying dataframe.</p> </li> </ul>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.linked_cubes",
      "title": "<code>linked_cubes: CubeLinks</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>CubeLinks</code>           \u2013            <p>A list of linked cubes that are linked to this cube.</p> </li> </ul>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.schema",
      "title": "<code>schema: Schema</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>Schema</code>           \u2013            <p>The Schema of the Cube which defines the dimensions and measures of the Cube.</p> </li> </ul>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.df",
      "title": "<code>df: pd.DataFrame</code>  <code>property</code>",
      "text": "<p>Returns: The underlying Pandas dataframe of the Cube.</p>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.dimensions",
      "title": "<code>dimensions: DimensionCollection</code>  <code>property</code>",
      "text": "<p>Returns:</p> <ul> <li> <code>DimensionCollection</code>           \u2013            <p>The dimensions available through the Cube.</p> </li> </ul>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.size_in_bytes",
      "title": "<code>size_in_bytes: int</code>  <code>property</code>",
      "text": "<p>Returns: The size in bytes allocated by the <code>Cube</code> object instance. The memory allocation by the underlying dataframe is not included.</p>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.__init__",
      "title": "<code>__init__(df, schema=None, infer_schema=True, exclude=None, read_only=True, ignore_member_key_errors=True, ignore_case=True, ignore_key_errors=True, caching=CachingStrategy.LAZY, caching_threshold=EAGER_CACHING_THRESHOLD, eager_evaluation=True)</code>",
      "text": "<p>Wraps a Pandas dataframes into a cube to provide convenient multi-dimensional access to the underlying dataframe for easy aggregation, filtering, slicing, reporting and data manipulation and write back.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>The Pandas dataframe to be wrapped into the CubedPandas <code>Cube</code> object.</p> </li> <li> <code>schema</code>           \u2013            <p>(optional) A schema that defines the dimensions and measures of the Cube. If not provided, the schema will be inferred from the dataframe if parameter <code>infer_schema</code> is set to <code>True</code>. For further details please refer to the documentation of the <code>Schema</code> class. Default value is <code>None</code>.</p> </li> <li> <code>infer_schema</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>(optional) If no schema is provided and <code>infer_schema</code> is set to True, a suitable schema will be inferred from the unerlying dataframe. All numerical columns will be treated as measures, all other columns as dimensions. If this behaviour is not desired, a schema must be provided. Default value is <code>True</code>.</p> </li> <li> <code>exclude</code>               (<code>str | list | tuple | None</code>, default:                   <code>None</code> )           \u2013            <p>(optional) Defines the columns that should be excluded from the cube if no schema is provied. If a column is excluded, it will not be part of the schema and can not be accessed through the cube. Excluded columns will be ignored during schema inference. Default value is <code>None</code>.</p> </li> <li> <code>read_only</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>(optional) Defines if write backs to the underlying dataframe are permitted. If read_only is set to <code>True</code>, write back attempts will raise an <code>PermissionError</code>. If read_only is set to <code>False</code>, write backs are permitted and will be pushed back to the underlying dataframe. Default value is <code>True</code>.</p> </li> <li> <code>ignore_case</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>(optional) If set to <code>True</code>, the case of member names will be ignored, 'Apple' and 'apple' will be treated as the same member. If set to <code>False</code>, member names are case-sensitive, 'Apple' and 'apple' will be treated as different members. Default value is <code>True</code>.</p> </li> <li> <code>ignore_key_errors</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>(optional) If set to <code>True</code>, key errors for members of dimensions will be ignored and cell values will return 0.0 or <code>None</code> if no matching record exists. If set to <code>False</code>, key errors will be raised as exceptions when accessing cell values for non-existing members. Default value is <code>True</code>.</p> </li> <li> <code>caching</code>               (<code>CachingStrategy</code>, default:                   <code>LAZY</code> )           \u2013            <p>(optional) A caching strategy to be applied for accessing the cube. recommended value for almost all use cases is <code>CachingStrategy.LAZY</code>, which caches dimension members on first access. Caching can be beneficial for performance, but may also consume more memory. To cache all dimension members eagerly (on initialization of the cube), set this parameter to <code>CachingStrategy.EAGER</code>. Please refer to the documentation of 'CachingStrategy' for more information. Default value is <code>CachingStrategy.LAZY</code>.</p> </li> <li> <code>caching_threshold</code>               (<code>int</code>, default:                   <code>EAGER_CACHING_THRESHOLD</code> )           \u2013            <p>(optional) The threshold as 'number of members' for EAGER caching only. If the number of distinct members in a dimension is below this threshold, the dimension will be cached eargerly, if caching is set to <code>CacheStrategy.EAGER</code> or <code>CacheStrategy.FULL</code>. Above this threshold, the dimension will be cached lazily. Default value is <code>EAGER_CACHING_THRESHOLD</code>, equivalent to 256 unique members per dimension.</p> </li> <li> <code>eager_evaluation</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>(optional) If set to <code>True</code>, the cube will evaluate the context eagerly, i.e. when the context is created. Eager evaluation is recommended for most use cases, as it simplifies debugging and error handling. If set to <code>False</code>, the cube will evaluate the context lazily, i.e. only when the value of a context is accessed/requested.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A new Cube object that wraps the dataframe.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PermissionError</code>             \u2013            <p>If writeback is attempted on a read-only Cube.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the schema is not valid or does not match the dataframe or if invalid dimension, member, measure or address agruments are provided.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.value([{\"product\": [\"A\", \"B\", \"C\"]}, {\"value\": [1, 2, 3]}])\n&gt;&gt;&gt; cdf = cubed(df)\n&gt;&gt;&gt; cdf[\"product:B\"]\n2\n</code></pre>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.__len__",
      "title": "<code>__len__()</code>",
      "text": "<p>Returns:</p> <ul> <li>           \u2013            <p>The number of records in the underlying dataframe of the Cube.</p> </li> </ul>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.clear_cache",
      "title": "<code>clear_cache()</code>",
      "text": "<p>Clears the cache of the Cube for all dimensions.</p>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.__getattr__",
      "title": "<code>__getattr__(name)</code>",
      "text": "<p>Dynamically resolves dimensions, measure or member from the cube. This enables a more natural access to the cube data using the Python dot notation.</p> <p>If the name is not a valid Python identifier and contains special characters or whitespaces or start with numbers, then the <code>slicer</code> method needs to be used to resolve the name, e.g., if <code>12 data %</code> is the name of a column or value in a dataframe, then <code>cube[\"12 data %\"]</code> needs to be used to return the dimension, measure or column.</p> <p>Parameters:</p> <ul> <li> <code>name</code>           \u2013            <p>Existing Name of a dimension, member or measure in the cube.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Context | CubeContext</code>           \u2013            <p>A Cell object that represents the cube data related to the address.</p> </li> </ul> Samples <p>cdf = cubed(df) cdf.Online.Apple.cost 50</p>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.__getitem__",
      "title": "<code>__getitem__(address)</code>",
      "text": "<p>Returns a cell of the cube for a given address. Args:     address:         A valid cube address.         Please refer the documentation for further details.</p> <p>Returns:</p> <ul> <li> <code>Context</code>           \u2013            <p>A Cell object that represents the cube data related to the address.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the address is not valid or can not be resolved.</p> </li> </ul>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.__setitem__",
      "title": "<code>__setitem__(address, value)</code>",
      "text": "<p>Sets a value for a given address in the cube. Args:     address:         A valid cube address.         Please refer the documentation for further details.     value:         The value to be set for the data represented by the address. Raises:     PermissionError:         If write back is attempted on a read-only Cube.</p>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.__delitem__",
      "title": "<code>__delitem__(address)</code>",
      "text": "<p>Deletes the records represented by the given address from the underlying dataframe of the cube. Args:     address:         A valid cube address.         Please refer the documentation for further details. Raises:     PermissionError:         If write back is attempted on a read-only Cube.</p>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.slice",
      "title": "<code>slice(rows=None, columns=None, config=None)</code>",
      "text": "<p>Returns a new slice for the cube. A slice represents a table-alike view to data in the cube. Typically, a slice has rows, columns and filters, comparable to an Excel PivotTable. Useful for printing in Jupyter, visual data analysis and reporting purposes. Slices can be easily 'navigated' by setting and changing rows, columns and filters.</p> <p>Please refer to the documentation of the Slice class for further details.</p> Samples <p>cdf = cubed(df) cdf.slice(rows=\"product\", columns=\"region\", filters={\"year\": 2020})</p>"
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.slice--year-2000",
      "title": "year: 2000",
      "text": ""
    },
    {
      "location": "api/class-cube/#cubedpandas.cube.Cube.slice--all-north-south",
      "title": "|         | (all) | North | South |",
      "text": "<p>| (all)   |   550 |   300 |   250 | | Apple   |   200 |   100 |   100 | | Banana  |   350 |   200 |   150 |</p>"
    },
    {
      "location": "api/class-dimension/",
      "title": "Dimension class",
      "text": "<p>               Bases: <code>Iterable</code>, <code>ABC</code></p> <p>Represents a dimension of a cube, mapped to a column in the underlying Pandas dataframe.</p>"
    },
    {
      "location": "api/class-dimension/#cubedpandas.schema.Dimension.df",
      "title": "<code>df: pd.DataFrame</code>  <code>property</code>",
      "text": "<p>Returns the underlying Pandas dataframe the dimension/column refers to.</p>"
    },
    {
      "location": "api/class-dimension/#cubedpandas.schema.Dimension.members",
      "title": "<code>members: list</code>  <code>property</code>",
      "text": "<p>Returns the list of members of the dimension.</p>"
    },
    {
      "location": "api/class-dimension/#cubedpandas.schema.Dimension.member_set",
      "title": "<code>member_set: set</code>  <code>property</code>",
      "text": "<p>Returns the set of members of the dimension.</p>"
    },
    {
      "location": "api/class-dimension/#cubedpandas.schema.Dimension.column",
      "title": "<code>column</code>  <code>property</code>",
      "text": "<p>Returns the column name in the underlying Pandas dataframe the dimension refers to.</p>"
    },
    {
      "location": "api/class-dimension/#cubedpandas.schema.Dimension.name",
      "title": "<code>name</code>  <code>property</code>",
      "text": "<p>Returns the name (column name in the underlying Pandas dataframe) of the dimension.</p>"
    },
    {
      "location": "api/class-dimension/#cubedpandas.schema.Dimension.dtype",
      "title": "<code>dtype</code>  <code>property</code>",
      "text": "<p>Returns the Pandas data type of the dimension column.</p>"
    },
    {
      "location": "api/class-dimension/#cubedpandas.schema.Dimension.__init__",
      "title": "<code>__init__(df, column, caching=CachingStrategy.LAZY)</code>",
      "text": "<p>Initializes a new Dimension from a Pandas dataframe and a column name.</p>"
    },
    {
      "location": "api/class-dimension/#cubedpandas.schema.Dimension.__getattr__",
      "title": "<code>__getattr__(name)</code>",
      "text": "<p>Dynamically resolves a Filter based on member names from the dimension. This enables a more natural access to the cube data using the Python dot notation.</p> <p>Member names need to be valid Python identifier/variable name. CubedPandas applies the following rules to resolve member names: - If a member name is also a valid Python identifier, it can be used directly. e.g., <code>Apple</code> - Member name resolving is case-insensitive, e.g., <code>apple</code> will resolve <code>Apple</code>. - White spaces in member names are replaced by underscores, e.g., <code>best_offer</code> will resolve <code>best offer</code>. - Leading numbers in a member name are replaced by underscores, e.g., <code>_2_cute</code> will resolve <code>2 cute</code>. - Leading and trailing underscores are ignored/removed, e.g., <code>hello</code> will resolve <code>hello</code>. - All other special characters are removed, e.g., <code>12/4 cars</code> is the same as <code>124_cars</code>.</p> <ul> <li>If the name is not a valid Python identifier (e.g. contains special characters), the <code>slicer</code> method needs to be used to resolve the member name. e.g., <code>12/4 cars</code> is a valid name for a value</li> </ul> <p>If the name is not a valid Python identifier (e.g. contains special characters), the <code>slicer</code> method needs to be used to resolve the member name. e.g., <code>12/4 cars</code> is a valid name for a value in a Pandas dataframe column, but not a valid Python identifier/variable name, hence <code>dimension[\"12/4 cars\"]</code> needs to be used to return the member.</p> <p>Parameters:</p> <ul> <li> <code>name</code>           \u2013            <p>Name of a member or measure in the cube.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A Cell object that represents the cube data related to the address.</p> </li> </ul> Samples <p>cdf = cubed(df) cdf.Online.Apple.cost 50</p>"
    },
    {
      "location": "api/class-dimension/#cubedpandas.schema.Dimension.clear_cache",
      "title": "<code>clear_cache()</code>",
      "text": "<p>Clears the cache of the Dimension.</p>"
    },
    {
      "location": "api/class-dimension/#cubedpandas.schema.Dimension.wildcard_filter",
      "title": "<code>wildcard_filter(pattern)</code>",
      "text": "<p>Returns a list of members that match the given wildcard pattern.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>           \u2013            <p>A wildcard pattern to filter the dimension members.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>(bool, list)</code>           \u2013            <p>A new DimensionFilter object.</p> </li> </ul>"
    },
    {
      "location": "api/class-dimension/#cubedpandas.schema.Dimension.count",
      "title": "<code>count(member)</code>",
      "text": "<p>Returns the number of rows in the underlying dataframe where the dimension column contains the given member.</p>"
    },
    {
      "location": "api/class-dimension/#cubedpandas.schema.Dimension.choice",
      "title": "<code>choice()</code>",
      "text": "<p>Return a random member from the dimension.</p> <p>See https://docs.python.org/3/library/random.html#random.choice for more information.</p> <p>Returns:</p> <ul> <li>           \u2013            <p>Return a random member from the dimension.</p> </li> </ul>"
    },
    {
      "location": "api/class-dimension/#cubedpandas.schema.Dimension.choices",
      "title": "<code>choices(k=1, weights=None, cum_weights=None)</code>",
      "text": "<p>Return a <code>k</code> sized list of members chosen from the dimension (with replacement).</p> <p>See https://docs.python.org/3/library/random.html#random.choices for more information.</p> <p>Returns:</p> <ul> <li>           \u2013            <p>Return a <code>k</code> sized list of members chosen from the dimension (with replacement).</p> </li> </ul>"
    },
    {
      "location": "api/class-dimension/#cubedpandas.schema.Dimension.sample",
      "title": "<code>sample(k=1, counts=None)</code>",
      "text": "<p>Return a <code>k</code> sized list of unique members chosen from the dimension (without replacement).</p> <p>See https://docs.python.org/3/library/random.html#random.sample for more information.</p> <p>Returns:</p> <ul> <li>           \u2013            <p>Return a <code>k</code> sized list of unique members chosen from the dimension (without replacement).</p> </li> </ul>"
    },
    {
      "location": "api/class-measure/",
      "title": "CubedPandas Measure Class",
      "text": "<p>Represents a measure within a Cube. Each measure is mapped to a column in the underlying Pandas dataframe.</p>"
    },
    {
      "location": "api/class-measure/#cubedpandas.schema.Measure.column",
      "title": "<code>column</code>  <code>property</code>",
      "text": "<p>Returns the column name in underlying Pandas dataframe the measure refers to.</p>"
    },
    {
      "location": "api/class-measure/#cubedpandas.schema.Measure.df",
      "title": "<code>df: pd.DataFrame</code>  <code>property</code>",
      "text": "<p>Returns the underlying Pandas dataframe of the cube.</p>"
    },
    {
      "location": "api/class-schema/",
      "title": "CubedPandas Schema Class",
      "text": "<p>Defines a multidimensional schema, for cell-based data access to a Pandas dataframe using an Cube.</p> <p>The schema defines the dimensions and measures of the cube and can be either inferred from the underlying Pandas dataframe automatically or defined explicitly. The schema can be validated against the Pandas dataframe to ensure the schema is valid for the table.</p>"
    },
    {
      "location": "api/class-schema/#cubedpandas.schema.Schema.dimensions",
      "title": "<code>dimensions: DimensionCollection</code>  <code>property</code>",
      "text": "<p>Returns the dimensions of the schema.</p>"
    },
    {
      "location": "api/class-schema/#cubedpandas.schema.Schema.measures",
      "title": "<code>measures: MeasureCollection</code>  <code>property</code>",
      "text": "<p>Returns the measures of the schema.</p>"
    },
    {
      "location": "api/class-schema/#cubedpandas.schema.Schema.__init__",
      "title": "<code>__init__(df=None, schema=None, caching=CachingStrategy.LAZY)</code>",
      "text": "<p>Initializes a new schema for a Cube upon a given Pandas dataframe. If the dataframe is not provided, the schema needs to be built manually and can also not be validated against the Pandas dataframe.</p> <p>For building a schema manually, you can either create a new schema from scratch or you can load, extend and modify an existing schema as defined by parameter <code>schema</code>. The parameter <code>schema</code> can either be another Schema object, a Python dictionary containing valid schema information, a json string containing valid schema information or a file name or path to a json file containing valid schema information.</p> <p>:param df: (optional) the Pandas dataframe to build the schema from or for. :param schema: (optional) a schema to initialize the Schema with. The parameter <code>schema</code> can either be         another Schema object, a Python dictionary containing valid schema information, a json string         containing valid schema information or a file name or path to a json file containing valid schema         information. :param caching: The caching strategy to be used for the Cube. Default is <code>CachingStrategy.LAZY</code>. Please refer to         the documentation of 'CachingStrategy' for more information.</p>"
    },
    {
      "location": "api/class-schema/#cubedpandas.schema.Schema.validate",
      "title": "<code>validate(df)</code>",
      "text": "<p>Validates the schema against an existing Pandas dataframe.</p> <p>If returned True, the schema is valid for the given Pandas dataframe and can be used to access its data. Otherwise, the schema is not valid and will or may lead to errors when accessing its data.</p> <p>:param df: The Pandas dataframe to validate the schema against.</p> <p>:return: Returns True if the schema is valid for the given Pandas dataframe, otherwise False.</p>"
    },
    {
      "location": "api/class-schema/#cubedpandas.schema.Schema.infer_schema",
      "title": "<code>infer_schema(exclude=None)</code>",
      "text": "<p>Infers a multidimensional schema from the Pandas dataframe of the Schema or another Pandas dataframe by analyzing the columns of the table and their contents.</p> <p>This process can be time-consuming for large tables. For such cases, it is recommended to infer the schema only from a sample of the records by setting parameter 'sample_records' to True. By default, the schema is inferred from and validated against all records.</p> <p>The inference process tries to identify the dimensions and their hierarchies of the cube as well as the measures of the cube. If no schema cannot be inferred, an exception is raised.</p> <p>By default, string, datetime and boolean columns are assumed to be measure columns and numerical columns are assumed to be measures for cube computations. By default, all columns of the Pandas dataframe will be used to infer the schema. However, a subset of columns can be specified to infer the schema from. The subset needs to contain at least two columns, one for a single dimensions and one for a single measures.</p> <p>For more complex tables it is possible or even likely that the resulting schema does not match your expectations or requirements. For such cases, you will need to build your schema manually. Please refer the documentation for further details on how to build a schema manually.</p> <p>:param exclude: (optional) a list of either column names or ordinal column ids to exclude when     inferring the schema.</p> <p>:return: Returns the inferred schema.</p>"
    },
    {
      "location": "api/class-schema/#cubedpandas.schema.Schema.from_dict",
      "title": "<code>from_dict(dictionary)</code>  <code>classmethod</code>",
      "text": "<p>Creates a new schema from a dictionary containing schema information for a Cube. Please refer to the documentation for further details on valid schema definitions.</p> <p>:param dictionary: The dictionary containing the schema information. :return: Returns a new schema object. :exception: Raises an exception if the schema information is not valid or incomplete.</p>"
    },
    {
      "location": "api/class-schema/#cubedpandas.schema.Schema.from_json",
      "title": "<code>from_json(json_string)</code>  <code>classmethod</code>",
      "text": "<p>Creates a new schema from a json string containing schema information for a Cube. If the json string is not valid and does refer to a file that contains a valid schema in json format, an exception is raised. Please refer to the documentation for further details on valid schema definitions.</p> <p>:param json_string: The json string containing the schema information. :return: Returns a new schema object. :exception: Raises an exception if the schema information is not valid or incomplete.</p>"
    },
    {
      "location": "api/class-schema/#cubedpandas.schema.Schema.to_dict",
      "title": "<code>to_dict()</code>",
      "text": "<p>Converts the schema into a dictionary containing schema information for an Cube.</p> <p>:return: Returns a dictionary containing the schema information.</p>"
    },
    {
      "location": "api/class-schema/#cubedpandas.schema.Schema.to_json",
      "title": "<code>to_json()</code>",
      "text": "<p>Converts the schema into a dictionary containing schema information for an Cube.</p> <p>:return: Returns a dictionary containing the schema information.</p>"
    },
    {
      "location": "api/class-schema/#cubedpandas.schema.Schema.save_as_json",
      "title": "<code>save_as_json(file_name)</code>",
      "text": "<p>Saves the schema as a json file.</p> <p>:param file_name: The name of the file to save the schema to.</p>"
    },
    {
      "location": "api/class-schema/#cubedpandas.schema.Schema.__len__",
      "title": "<code>__len__()</code>",
      "text": "<p>Returns the number of dimensions of the schema.</p>"
    },
    {
      "location": "api/method-cubed/",
      "title": "Wrapping a Pandas DataFrame into a CubedPandas Cube",
      "text": ""
    },
    {
      "location": "api/method-cubed/#using-the-cubed-method",
      "title": "Using the 'cubed()' Method",
      "text": "<p>The <code>cubed</code> function is the most convenient way to wrap and convert a Pandas dataframe into a CubedPandas cube. by the way, <code>cdf</code> is nice and short for a 'cubed data frame' following the Pandas convention of <code>df</code> for a 'data frame'.</p> <p>If no schema is provided when applying the <code>cubed</code> method, a schema will be automatically inferred from the DataFrame.  By default, all numeric columns will be considered as measures, all other columns as dimensions of the cube.</p> <pre><code>import pandas as pd\nfrom cubedpandas import cubed\n\ndf = pd.DataFrame({\"channel\": [\"Online\", \"Online\", \"Online\", \"Retail\", \"Retail\", \"Retail\"],\n                   \"product\": [\"Apple\",  \"Pear\",   \"Banana\", \"Apple\",  \"Pear\",   \"Banana\"],\n                   \"sales\":   [100,      150,      300,      200,      250,      350     ],})\ncdf = cubed(df)    \nprint(cdf.Online)  # returns 550 = 100 + 150 + 300\n</code></pre> <p>Sometimes, e.g. if you want an <code>integer</code> column to be considered as a dimension not as a measure column,  you need to provide a schema. Here's a simple example of how to define and use a schema, here identical  to schema that will be automatically inferred. For more information please refer to the  Schema documentation.</p> <pre><code>import pandas as pd\nfrom cubedpandas import cubed\n\ndf = pd.DataFrame({\"channel\": [\"Online\", \"Online\", \"Online\", \"Retail\", \"Retail\", \"Retail\"],\n                   \"product\": [\"Apple\",  \"Pear\",   \"Banana\", \"Apple\",  \"Pear\",   \"Banana\"],\n                   \"sales\":   [100,      150,      300,      200,      250,      350     ],})\nschema = {\"dimensions\": [{\"column\":\"channel\"}, {\"column\": \"product\"}],\n          \"measures\":   [{\"column\":\"sales\"}]}\ncdf = cubed(df, schema=schema)\nprint(cdf.Online)  # returns 550 = 100 + 150 + 300\n</code></pre>"
    },
    {
      "location": "api/method-cubed/#using-the-cubed-extension-for-python",
      "title": "Using the 'cubed' extension for Python",
      "text": "<p>After CubedPandas has been loaded, e.g. by <code>import cubedpandas</code>, you can also directly use the <code>cubed</code> extension for Pandas. The only difference to the <code>cubed()</code> function is, that you need to use the <code>cubed</code> attribute of the Pandas DataFrame and either slice it with the <code>[]</code> operator or get access to the cube or any context  using the <code>.</code> operator.  </p> <pre><code>import pandas as pd\nimport cubedpandas\n\ndf = pd.DataFrame({\"channel\": [\"Online\", \"Online\", \"Online\", \"Retail\", \"Retail\", \"Retail\"],\n                   \"product\": [\"Apple\",  \"Pear\",   \"Banana\", \"Apple\",  \"Pear\",   \"Banana\"],\n                   \"sales\":   [100,      150,      300,      200,      250,      350     ],})\n\ncdf = df.cubed.cube  # return a reference to the cube, just 'df.cubed' will not work.\n# or directly access any context the cube either by slicing with the [] operator\nx = df.cubed[\"Online\", \"Apple\", \"sales\"]\n# or by using the . operator\ny = df.cubed.Online.Apple.sales\n\nassert(x == y == 100)\n</code></pre>"
    },
    {
      "location": "api/method-cubed/#cubedpandas.common.cubed",
      "title": "<code>cubed(df, schema=None, infer_schema=True, exclude=None, caching=CachingStrategy.LAZY, caching_threshold=EAGER_CACHING_THRESHOLD, read_only=True)</code>",
      "text": "<p>Wraps a Pandas dataframes into a cube to provide convenient multi-dimensional access to the underlying dataframe for easy aggregation, filtering, slicing, reporting and data manipulation and write back.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>The Pandas dataframe to be wrapped into the CubedPandas <code>Cube</code> object.</p> </li> <li> <code>schema</code>           \u2013            <p>(optional) A schema that defines the dimensions and measures of the Cube. If not provided, the schema will be inferred from the dataframe if parameter <code>infer_schema</code> is set to <code>True</code>. For further details please refer to the documentation of the <code>Schema</code> class. Default value is <code>None</code>.</p> </li> <li> <code>infer_schema</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>(optional) If no schema is provided and <code>infer_schema</code> is set to True, a suitable schema will be inferred from the unerlying dataframe. All numerical columns will be treated as measures, all other columns as dimensions. If this behaviour is not desired, a schema must be provided. Default value is <code>True</code>.</p> </li> <li> <code>exclude</code>               (<code>str | list | tuple | None</code>, default:                   <code>None</code> )           \u2013            <p>(optional) Defines the columns that should be excluded from the cube if no schema is provied. If a column is excluded, it will not be part of the schema and can not be accessed through the cube. Excluded columns will be ignored during schema inference. Default value is <code>None</code>.</p> </li> <li> <code>caching</code>               (<code>CachingStrategy</code>, default:                   <code>LAZY</code> )           \u2013            <p>(optional) A caching strategy to be applied for accessing the cube. recommended value for almost all use cases is <code>CachingStrategy.LAZY</code>, which caches dimension members on first access. Caching can be beneficial for performance, but may also consume more memory. To cache all dimension members eagerly (on initialization of the cube), set this parameter to <code>CachingStrategy.EAGER</code>. Please refer to the documentation of 'CachingStrategy' for more information. Default value is <code>CachingStrategy.LAZY</code>.</p> </li> <li> <code>caching_threshold</code>               (<code>int</code>, default:                   <code>EAGER_CACHING_THRESHOLD</code> )           \u2013            <p>(optional) The threshold as 'number of members' for EAGER caching only. If the number of distinct members in a dimension is below this threshold, the dimension will be cached eargerly, if caching is set to CacheStrategy.EAGER or CacheStrategy.FULL. Above this threshold, the dimension will be cached lazily. Default value is <code>EAGER_CACHING_THRESHOLD</code>, equivalent to 256 unique members per dimension.</p> </li> <li> <code>read_only</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>(optional) Defines if write backs to the underlying dataframe are permitted. If read_only is set to <code>True</code>, write back attempts will raise an <code>PermissionError</code>. If read_only is set to <code>False</code>, write backs are permitted and will be pushed back to the underlying dataframe. Default value is <code>True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A new Cube object that wraps the dataframe.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PermissionError</code>             \u2013            <p>If writeback is attempted on a read-only Cube.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the schema is not valid or does not match the dataframe or if invalid dimension, member, measure or address agruments are provided.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.value([{\"product\": [\"A\", \"B\", \"C\"]}, {\"value\": [1, 2, 3]}])\n&gt;&gt;&gt; cdf = cubed(df)\n&gt;&gt;&gt; cdf[\"product:B\"]\n2\n</code></pre>"
    },
    {
      "location": "api/method-cubed/#cubedpandas.pandas_extension.CubedPandasAccessor",
      "title": "<code>CubedPandasAccessor</code>",
      "text": "<p>A Pandas extension that provides the CubedPandas 'cubed' accessor for Pandas dataframes.</p>"
    },
    {
      "location": "api/method-cubed/#cubedpandas.pandas_extension.CubedPandasAccessor.cube",
      "title": "<code>cube</code>  <code>property</code>",
      "text": "<p>Wraps a Pandas dataframes into a cube to provide convenient multi-dimensional access to the underlying dataframe for easy aggregation, filtering, slicing, reporting and data manipulation and write back.</p> <p>Parameters:</p> <ul> <li> <code>df</code>           \u2013            <p>The Pandas dataframe to be wrapped into the CubedPandas <code>Cube</code> object.</p> </li> <li> <code>schema</code>           \u2013            <p>(optional) A schema that defines the dimensions and measures of the Cube. If not provided, the schema will be inferred from the dataframe if parameter <code>infer_schema</code> is set to <code>True</code>. For further details please refer to the documentation of the <code>Schema</code> class. Default value is <code>None</code>.</p> </li> <li> <code>infer_schema</code>           \u2013            <p>(optional) If no schema is provided and <code>infer_schema</code> is set to True, a suitable schema will be inferred from the unerlying dataframe. All numerical columns will be treated as measures, all other columns as dimensions. If this behaviour is not desired, a schema must be provided. Default value is <code>True</code>.</p> </li> <li> <code>exclude</code>           \u2013            <p>(optional) Defines the columns that should be excluded from the cube if no schema is provied. If a column is excluded, it will not be part of the schema and can not be accessed through the cube. Excluded columns will be ignored during schema inference. Default value is <code>None</code>.</p> </li> <li> <code>read_only</code>           \u2013            <p>(optional) Defines if write backs to the underlying dataframe are permitted. If read_only is set to <code>True</code>, write back attempts will raise an <code>PermissionError</code>. If read_only is set to <code>False</code>, write backs are permitted and will be pushed back to the underlying dataframe. Default value is <code>True</code>.</p> </li> <li> <code>ignore_case</code>           \u2013            <p>(optional) If set to <code>True</code>, the case of member names will be ignored, 'Apple' and 'apple' will be treated as the same member. If set to <code>False</code>, member names are case-sensitive, 'Apple' and 'apple' will be treated as different members. Default value is <code>True</code>.</p> </li> <li> <code>ignore_key_errors</code>           \u2013            <p>(optional) If set to <code>True</code>, key errors for members of dimensions will be ignored and cell values will return 0.0 or <code>None</code> if no matching record exists. If set to <code>False</code>, key errors will be raised as exceptions when accessing cell values for non-existing members. Default value is <code>True</code>.</p> </li> <li> <code>caching</code>           \u2013            <p>(optional) A caching strategy to be applied for accessing the cube. recommended value for almost all use cases is <code>CachingStrategy.LAZY</code>, which caches dimension members on first access. Caching can be beneficial for performance, but may also consume more memory. To cache all dimension members eagerly (on initialization of the cube), set this parameter to <code>CachingStrategy.EAGER</code>. Please refer to the documentation of 'CachingStrategy' for more information. Default value is <code>CachingStrategy.LAZY</code>.</p> </li> <li> <code>caching_threshold</code>           \u2013            <p>(optional) The threshold as 'number of members' for EAGER caching only. If the number of distinct members in a dimension is below this threshold, the dimension will be cached eargerly, if caching is set to <code>CacheStrategy.EAGER</code> or <code>CacheStrategy.FULL</code>. Above this threshold, the dimension will be cached lazily. Default value is <code>EAGER_CACHING_THRESHOLD</code>, equivalent to 256 unique members per dimension.</p> </li> <li> <code>eager_evaluation</code>           \u2013            <p>(optional) If set to <code>True</code>, the cube will evaluate the context eagerly, i.e. when the context is created. Eager evaluation is recommended for most use cases, as it simplifies debugging and error handling. If set to <code>False</code>, the cube will evaluate the context lazily, i.e. only when the value of a context is accessed/requested.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>A new Cube object that wraps the dataframe.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PermissionError</code>             \u2013            <p>If writeback is attempted on a read-only Cube.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the schema is not valid or does not match the dataframe or if invalid dimension, member, measure or address agruments are provided.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.value([{\"product\": [\"A\", \"B\", \"C\"]}, {\"value\": [1, 2, 3]}])\n&gt;&gt;&gt; cdf = cubed(df)\n&gt;&gt;&gt; cdf[\"product:B\"]\n</code></pre>"
    },
    {
      "location": "blog/",
      "title": "Blog",
      "text": ""
    },
    {
      "location": "blog/2024/06/16/welcome-to-cubedpandas/",
      "title": "Welcome",
      "text": "<p>Welcome to CubedPandas, the Python library to simplify and speed up your data analysis tasks with Pandas.</p> <p>Currently, I'm still in the ramp-up phase of the project, but I'm happy to have you here. Stay tuned for more updates and news about CubedPandas and how it can help people to speed up your data analysis tasks.</p> <p>Thomas</p>",
      "tags": [
        "Welcome",
        "General"
      ]
    },
    {
      "location": "guides/best-practise-aggregations/",
      "title": "Best practise aggregations",
      "text": ""
    },
    {
      "location": "guides/best-practise-aggregations/#sorry-well-add-that-later",
      "title": "Sorry, we'll add that later...",
      "text": "<p>The current focus of development is on the core features of CubedPandas. Once finished I'll work on this documention...</p> <p>!!! Note: To stay tuned for updates and new releases of CubePandas, please add a watch to the CubedPandas GitHub repo.</p> <p>Thomas</p>"
    },
    {
      "location": "guides/best-practise-datetime/",
      "title": "Best practise datetime",
      "text": ""
    },
    {
      "location": "guides/best-practise-datetime/#sorry-well-add-that-later",
      "title": "Sorry, we'll add that later...",
      "text": "<p>The current focus of development is on the core features of CubedPandas. Once finished I'll work on this documention...</p> <p>!!! Note: To stay tuned for updates and new releases of CubePandas, please add a watch to the CubedPandas GitHub repo.</p> <p>Thomas</p>"
    },
    {
      "location": "guides/best-practise-filtering/",
      "title": "Best practise filtering",
      "text": ""
    },
    {
      "location": "guides/best-practise-filtering/#sorry-well-add-that-later",
      "title": "Sorry, we'll add that later...",
      "text": "<p>The current focus of development is on the core features of CubedPandas. Once finished I'll work on this documention...</p> <p>!!! Note: To stay tuned for updates and new releases of CubePandas, please add a watch to the CubedPandas GitHub repo.</p> <p>Thomas</p>"
    },
    {
      "location": "guides/best-practise-pivot-tables/",
      "title": "Best practise pivot tables",
      "text": ""
    },
    {
      "location": "guides/best-practise-pivot-tables/#sorry-well-add-that-later",
      "title": "Sorry, we'll add that later...",
      "text": "<p>The current focus of development is on the core features of CubedPandas. Once finished I'll work on this documention...</p> <p>!!! Note: To stay tuned for updates and new releases of CubePandas, please add a watch to the CubedPandas GitHub repo.</p> <p>Thomas</p>"
    },
    {
      "location": "guides/cheatsheet/",
      "title": "Cheatsheet",
      "text": ""
    },
    {
      "location": "guides/cheatsheet/#sorry-well-add-that-later",
      "title": "Sorry, we'll add that later...",
      "text": "<p>The current focus of development is on the core features of CubedPandas. Once finished I'll work on this documention...</p> <p>!!! Note: To stay tuned for updates and new releases of CubePandas, please add a watch to the CubedPandas GitHub repo.</p> <p>Thomas</p>"
    },
    {
      "location": "blog/archive/2024/",
      "title": "2024",
      "text": ""
    },
    {
      "location": "blog/category/project/",
      "title": "Project",
      "text": ""
    }
  ]
}